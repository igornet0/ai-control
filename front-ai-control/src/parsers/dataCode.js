// This file was generated by lezer-generator. You probably shouldn't edit it.
import {LRParser} from "@lezer/lr"
import { LanguageSupport, LRLanguage } from '@codemirror/language';
import { styleTags, tags as t } from '@lezer/highlight';
import { completeFromList } from '@codemirror/autocomplete';

export const parser = LRParser.deserialize({
  version: 14,
  states: "!|Q]QPOOOOQO'#Cb'#CbOOQO'#Ca'#CaOwQPO'#CiO|QPO'#ClOOQO'#C`'#C`OOQO'#Cn'#CnQ]QPOOO!RQPO,59TO!WQPO,59WOOQO-E6l-E6lO!]QPO1G.oO!]QPO1G.rOOQO7+$Z7+$ZOOQO7+$^7+$^",
  stateData: "!y~OeOSPOSQOS~OVPOWPOXPOYPOZPO[PO^ROaSO~OVWO~OVXO~O_ZO~O_[O~OVPOWPOXPOYPOZPO[PO~O^aYZ[VZ~",
  goto: "|cPPPPdhlPPPPPPhPPhPvTUOVTTOVSQOVQ]ZR^[QVORYV",
  nodeNames: "âš  LineComment BlockComment Script Statement ExprStmt Expr Identifier Number String true false null GlobalStmt global = LocalStmt local",
  maxTerm: 21,
  skippedNodes: [0,1,2],
  repeatNodeCount: 1,
  tokenData: "5^~ReXY!dYZ!d]^!dpq!drs!ust&qwx']!Q![(z!_!`)e!c!})j#R#S)j#T#Y)j#Y#Z){#Z#[,]#[#`)j#`#a/U#a#b)j#b#c1f#c#h)j#h#i3b#i#o)j~!iSe~XY!dYZ!d]^!dpq!d~!xWOY#bZr#brs%Us#O#b#O#P$S#P;'S#b;'S;=`%O<%lO#b~#eWOY#bZr#brs#}s#O#b#O#P$S#P;'S#b;'S;=`%O<%lO#b~$SOX~~$VRO;'S#b;'S;=`$`;=`O#b~$cXOY#bZr#brs#}s#O#b#O#P$S#P;'S#b;'S;=`%O;=`<%l#b<%lO#b~%RP;=`<%l#b~%ZPX~rs%^~%aTOr%^rs%ps;'S%^;'S;=`&k<%lO%^~%sTOr%^rs&Ss;'S%^;'S;=`&k<%lO%^~&VTOr%^rs&fs;'S%^;'S;=`&k<%lO%^~&kOQ~~&nP;=`<%l%^~&vTP~OY&qZ]&q^;'S&q;'S;=`'V<%lO&q~'YP;=`<%l&q~'`WOY']Zw']wx#}x#O']#O#P'x#P;'S'];'S;=`(t<%lO']~'{RO;'S'];'S;=`(U;=`O']~(XXOY']Zw']wx#}x#O']#O#P'x#P;'S'];'S;=`(t;=`<%l']<%lO']~(wP;=`<%l']~)PQW~!O!P)V!Q![(z~)YP!Q![)]~)bPW~!Q![)]~)jO_~~)oSV~!Q![)j!c!})j#R#S)j#T#o)j~*QTV~!Q![)j!c!})j#R#S)j#T#U*a#U#o)j~*fUV~!Q![)j!c!})j#R#S)j#T#`)j#`#a*x#a#o)j~*}UV~!Q![)j!c!})j#R#S)j#T#g)j#g#h+a#h#o)j~+fUV~!Q![)j!c!})j#R#S)j#T#X)j#X#Y+x#Y#o)j~,PSZ~V~!Q![)j!c!})j#R#S)j#T#o)j~,bUV~!Q![)j!c!})j#R#S)j#T#`)j#`#a,t#a#o)j~,yUV~!Q![)j!c!})j#R#S)j#T#c)j#c#d-]#d#o)j~-bUV~!Q![)j!c!})j#R#S)j#T#U)j#U#V-t#V#o)j~-yTV~!Q![)j!c!})j#R#S)j#T#U.Y#U#o)j~._UV~!Q![)j!c!})j#R#S)j#T#`)j#`#a.q#a#o)j~.xS^~V~!Q![)j!c!})j#R#S)j#T#o)j~/ZUV~!Q![)j!c!})j#R#S)j#T#c)j#c#d/m#d#o)j~/rUV~!Q![)j!c!})j#R#S)j#T#V)j#V#W0U#W#o)j~0ZTV~!Q![)j!c!})j#R#S)j#T#U0j#U#o)j~0oUV~!Q![)j!c!})j#R#S)j#T#`)j#`#a1R#a#o)j~1YSa~V~!Q![)j!c!})j#R#S)j#T#o)j~1kUV~!Q![)j!c!})j#R#S)j#T#i)j#i#j1}#j#o)j~2SUV~!Q![)j!c!})j#R#S)j#T#`)j#`#a2f#a#o)j~2kUV~!Q![)j!c!})j#R#S)j#T#`)j#`#a2}#a#o)j~3US[~V~!Q![)j!c!})j#R#S)j#T#o)j~3gUV~!Q![)j!c!})j#R#S)j#T#f)j#f#g3y#g#o)j~4OUV~!Q![)j!c!})j#R#S)j#T#i)j#i#j4b#j#o)j~4gUV~!Q![)j!c!})j#R#S)j#T#X)j#X#Y4y#Y#o)j~5QSY~V~!Q![)j!c!})j#R#S)j#T#o)j",
  tokenizers: [0],
  topRules: {"Script":[0,3]},
  tokenPrec: 79
})

// Create the language using the generated parser
const dataCodeLanguage = LRLanguage.define({
  name: 'datacode',
  parser: parser.configure({
    props: [
      styleTags({
        Identifier: t.variableName,
        Number: t.number,
        String: t.string,
        "global local true false null": t.keyword,
      })
    ]
  }),
  languageData: {
    commentTokens: { line: '#', block: { open: '"""', close: '"""' } },
    indentOnInput: /^\s*(endif|endfunction|forend|endtry|else|catch|finally)$/,
    closeBrackets: { brackets: ['(', '[', '{', '"', "'"] },
    wordChars: '$'
  }
});

// Define DataCode keywords for completions
const dataCodeKeywords = [
  'global', 'local', 'function', 'endfunction', 'if', 'else', 'endif',
  'for', 'forend', 'in', 'do', 'try', 'catch', 'endtry', 'finally',
  'throw', 'return', 'and', 'or', 'not', 'true', 'false', 'null'
];

// Create completions
const dataCodeCompletions = completeFromList([
  ...dataCodeKeywords.map(kw => ({
    label: kw,
    type: 'keyword'
  }))
]);

// Export the language support
export function dataCode() {
  return new LanguageSupport(dataCodeLanguage);
}

export { dataCodeCompletions };
